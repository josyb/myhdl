'''
Created on 29 okt. 2023

@author: josy
'''
import os
import sys
import inspect
import string
import warnings
import ast
import math

from icecream import ic
ic.configureOutput(argToStringFunction=str, outputFunction=print, includeContext=True, contextAbsPath=True)
from astpretty import pformat as astdump
import pprint
pp = pprint.PrettyPrinter(indent=4, width=120)

from myhdl import __version__ as myhdlversion
from myhdl import  ConversionError
from myhdl import bin as tobin
from myhdl import  ToVHDLWarning, ToVHDLError
from myhdl._concat import concat
from myhdl._delay import delay
from myhdl._enum import EnumType, EnumItemType
from myhdl._extractHierarchy import (_isMem, _getMemInfo, _UserVhdlCode)
from myhdl._intbv import intbv
from myhdl._modbv import modbv
from myhdl._misc import downrange
from myhdl._ShadowSignal import _TristateSignal, _TristateDriver
from myhdl._Signal import Constant, _Signal, _WaiterList, posedge, negedge, Constant
from myhdl._simulator import now
from myhdl.conversion._analyze import (_Rom, _Ram, _enumTypeSet)
from myhdl.conversion._misc import (_makeDoc, _error, _kind, _context, sortalign,
                                    _ConversionMixin, _Label, _genUniqueSuffix, _isConstant, getutcdatetime,
                                    sig_boolean, sig_enum, sig_int, sig_nat, sig_signed,
                                    sig_std_logic, sig_string, sig_type, sig_unsigned, sig_vector, inferSigObj, _loopInt)
from myhdl.conversion._toVHDLPackage import _package
from myhdl.conversion._VHDLNameValidation import _nameValid, _usedNames

myhdl_header = """\
-- File: $filename
-- Generated by MyHDL $version
-- Date: $date
"""

# _version = myhdlversion.replace('.', '')
# _shortversion, __, __ = _version.replace('dev', '').rpartition('.')  # loose the subminor version number
_shortversion, __, __ = myhdlversion.replace('dev', '').rpartition('.')  # loose the subminor version number
_shortversion = _shortversion.replace('.', '')

version_Major, version_minor, version_subminor = myhdlversion.split('.')


class VhdlWriter(object):
    __slots__ = (
                 "architecture",
                 "constwires",
                 "comment",
                 "dunder",
                 "_enumPortTypeSet",
                 "file",
                 "filename",
                 "hdl",
                 "header",
                 "ind",
                 "initial_values",
                 "library",
                 "needPck",
                 "no_myhdl_header",
                 "no_myhdl_package",
                 "no_testbench",
                 "path",
                 "portmap",
                 "radix",
                 "standard",
                 "std_logic_ports",
                 "timescale",
                 "trace",
                 "useClauses",
                 "usercode",
                 "ConvertAlwaysVisitor",
                 "ConvertInitialVisitor",
                 "ConvertSimpleAlwaysCombVisitor",
                 "ConvertAlwaysDecoVisitor",
                 "ConvertAlwaysSeqVisitor",
                 "ConvertAlwaysCombVisitor"
                 )

    def __init__(self, **kwargs):
        self.hdl = 'VHDL'
        self.comment = '-- '
        self.standard = '2008'
        self.timescale = 'ns'
        self.radix = ''
        self.header = ''
        self.no_testbench = True
        self.trace = False
        self.initial_values = False
        self.usercode = _UserVhdlCode
        self.ind = '    '  # start with indented code
        self.header = ''
        self.no_myhdl_header = False
        self.no_myhdl_package = False
        self.library = "work"
        self.useClauses = None
        self.architecture = "MyHDL"
        self.std_logic_ports = False
        self.initial_values = False
        self.constwires = []
        self._enumPortTypeSet = set()
        self.needPck = False
        self.dunder = 0

        for key, value in kwargs.items():
            ic(f"{key} = {value}")

        self.ConvertAlwaysVisitor = _ConvertAlwaysVisitor
        self.ConvertInitialVisitor = _ConvertInitialVisitor
        self.ConvertSimpleAlwaysCombVisitor = _ConvertSimpleAlwaysCombVisitor
        self.ConvertAlwaysDecoVisitor = _ConvertAlwaysDecoVisitor
        self.ConvertAlwaysSeqVisitor = _ConvertAlwaysSeqVisitor
        self.ConvertAlwaysCombVisitor = _ConvertAlwaysCombVisitor

    def openfile(self, name, directory):
        self.filename = name + ".vhd"
        path = os.path.join(directory, self.filename)
        setattr(self, 'file', open(path, 'w'))

    def writePackages(self, directory):
#        # write MyHDL package always during development, as it may change
#        pfile = None
#        if not os.path.isfile(ppath):
#            pfile = open(ppath, 'w')
        if not self.no_myhdl_package:
            print(f'writing VHDL Package for MyHDL{myhdlversion}')
            ppath = os.path.join(directory, "pck_myhdl.vhd")
            pfile = open(ppath, 'w')
            self.writeFileHeader(pfile)
            print(_package, file=pfile)
            pfile.close()

    def writeFileHeader(self, ofile):
        vvars = dict(filename=self.filename,
                    version=myhdlversion,
                    date=getutcdatetime()
                    )
        if not self.no_myhdl_header:
            print(string.Template(myhdl_header).substitute(vvars), file=ofile)
        if self.header:
            print(string.Template(self.header).substitute(vvars), file=ofile)
        print(file=ofile)

    def writeModuleHeader(self, intf):
        self.writeFileHeader(self.file)

        doc = _makeDoc(inspect.getdoc(intf), self.comment)

        ieeeheader = "library IEEE;\n" \
                     "    use IEEE.std_logic_1164.all;\n" \
                     "    use IEEE.numeric_std.all;\n\n" \
                     "    use std.textio.all;\n\n"
        self.file.write(ieeeheader)
        if self.library != "work":
            self.file.write(f"library {self.library};\n")
        if self.useClauses is not None:
            self.file.write(self.useClauses)
            self.file.write("\n")
        else:
            self.file.write(f"    use {self.library}.pck_myhdl.all;\n\n")
        if self.needPck:
            self.file.write(f"    use {self.library}.pck_{intf.name}.all;\n\n\n")
        self.file.write(f"entity {intf.name} is\n")

        if intf.argnames:
            self.file.write("    port (")
            c = ''
            for portname in intf.argnames:
                _nameValid(portname)
                s = intf.argdict[portname]
                self.file.write(f"{c}")
                c = ';'
                # change name to convert to std_logic, or
                # make sure signal name is equal to its port name
                convertPort = False
                # if stdLogicPorts and s._type is intbv:
                #     s._name = portname + "_num"
                #     convertPort = True
                #     # override the names given by _analyze.py
                #     for sl in s._slicesigs:
                #         sl._setName('VHDL')
                # else:
                s._name = portname
                r = _getRangeString(s)
                pt = _getTypeString(s)
                if convertPort:
                    pt = "std_logic_vector"

                if s._driven:
                    if s._read and isinstance(s, _TristateSignal):
                        self.file.write(f"\n        {portname}: inout {pt}{r}")
                    else:
                        self.file.write(f"\n        {portname}: out {pt}{r}")
                    # if convertPort:
                    #     portConversions.append("{} <= {}({});".format(portname, pt, s._name))
                    #     s._read = True
                else:
                    if not s._read:
                        warnings.warn(f"{_error.UnusedPort}: {portname}", category=ToVHDLWarning)
                    self.file.write(f"\n        {portname}: in {pt}{r}")
                    # if convertPort:
                    #     portConversions.append("{} <= {}({});".format(s._name, st, portname))
                    #     s._driven = True

            self.file.write("\n    );\n")
        self.file.write(f"end entity {intf.name};\n")
        self.file.write(doc)
        self.file.write(f"\n\narchitecture {self.architecture} of {intf.name} is\n\n")

    def writeDecls(self, intf, siglist, memlist):
        # must handle all these
        self._writeFuncDecls()
        self._writeTypeDefs()
        self._writeSigDecls(intf, siglist, memlist)
        #    no need for _writeCompDecls(compDecls) as we removed that feature in favor of 'inst: entity work.some_entity'
        self.file.write('\n\nbegin\n\n')
        #     assert <condition> report <message_string> severity <severity_level>;
        self.file.write(f'    assert check_package_version({version_Major}, {version_minor}, {version_subminor})\n' \
                        '    report "Check version of \'myhdl_pkg.vhd\'"\n' \
                        '    severity error;\n\n'
                        )
        # write out portconverions
        self.writePortConversions()
        # and constwires here
        self.writeConstantWires()
        self.writeConcatSignals(siglist, memlist)

    def _writeFuncDecls(self):
        return
        # print >> f, package

    def _writeTypeDefs(self):
        sortedList = list(_enumTypeSet)
        if sortedList:
            sortedList.sort(key=lambda x: x._name)
            self.file.write("\n")
            for t in sortedList:
        #         f.write("{}\n".format(t._toVHDL())
        #         typename, names, codes = t.reftype()
        #         for name in names:
        #             # watch out _nameValid() will add every name to a check-list
        #             # which will force you to be inventive with state names ...
        #             # e.g. the typical 'IDLE' can only be used once
        #             # so let's pre-fix the enum name
        #             # we could have modified _nameValid() to take a default boolean argument
        #             _nameValid(''.join((typename, '.', name)))
        #
        #         enumtypedecl = "type {} is (\n\t".format(typename
        #         enumtypedecl += ",\n\t".join(names)
        #         enumtypedecl += "\n\t);\n"
        #         if codes is not None:
        #             enumtypedecl += 'attribute enum_encoding of {}: type is "{}";\n'.format(typename, codes)
        #         f.write('{}'.format(enumtypedecl))
                self._writeEnum(t)
            # a final blank separator line
            self.file.write("\n")

    def _writeEnum(self, e):
        typename, names, codes = e.reftype()
        for name in names:
            # watch out _nameValid() will add every name to a check-list
            # which will force you to be inventive with state names ...
            # e.g. the typical 'IDLE' can only be used once
            # so let's pre-fix the enum name
            # we could have modified _nameValid() to take a default boolean argument
            _nameValid(''.join((typename, '.', name)))

        enumtypedecl = f"type {typename} is (\n\t"
        enumtypedecl += ",\n\t".join(names)
        enumtypedecl += "\n\t);\n"
        if codes is not None:
            enumtypedecl += f'attribute enum_encoding of{typename}: type is "{codes}";\n'
        self.file.write('{}'.format(enumtypedecl))

    def _writeSigDecls(self, intf, siglist, memlist):
        ic(intf, siglist, memlist)
        del self.constwires[:]
        sigs = []
        for s in siglist:
            if not s._used:
                continue

            if s._name in intf.argnames:
                continue

            if s._name.startswith('-- OpenPort'):
                # do not write a signal declaration for OpenPort'ed outputs
                continue

            r = _getRangeString(s)
            p = _getTypeString(s)
            # Check if VHDL keyword or reused name
            _nameValid(s._name)
            if s._driven:
                if not s._read and not isinstance(s, _TristateDriver):
                    warnings.warn(f"{_error.UnreadSignal}: { s._name}", category=ToVHDLWarning)
                # the following line implements initial value assignments

                if not self.initial_values:
                    val_str = ""
                else:
                    if isinstance(s._val, intbv):
                        if s._val.min < 0:
                            val_str = f' := {len(s)}X"{s._init}"'
                        else:
                            val_str = f' := {len(s)}X"{s._init}"'

                    elif isinstance(s._val, bool):
                        val_str = f" := '{s._init}'"
                    elif isinstance(s._val, EnumType):
                        val_str = f' := {s._init}'
                    #
                    # if isinstance(sig_vhdl_obj, vhd_std_logic):
                    #     # Single bit
                    #     val_str = " := '{}'".format(int(s._init)
                    # elif isinstance(sig_vhdl_obj, vhd_int):
                    #     val_str = " := {}".format(s._init
                    # elif isinstance(sig_vhdl_obj, (vhd_signed, vhd_unsigned)):
                    #     val_str = ' := {}X"{}"'.format(
                    #         sig_vhdl_obj.size, str(s._init))
                    #
                    # elif isinstance(sig_vhdl_obj, vhd_enum):
                    #     val_str = ' := {}'.format(s._init,)

                    else:
                        # default to no initial value
                        val_str = ''

                sigs.append(f"signal {s._name}: {p}{r}{val_str};")

            elif s._read:
                if isinstance(s, Constant):
                    if isinstance(s._val, intbv):
                        if s._init:
                            sigs.append(f'constant {s._name}: {p}{r} := {s._nrbits}X"{str(s._init)}" /* {int(s._init)} */;')
                        else:
                            sigs.append(f'constant {s._name}: {p}{r} := {s._nrbits}X"0";')
                    else:
                        sinitstr = "'1'" if s._init else "'0'"
                        sigs.append(f"constant {s._name}: {p}{r} := {sinitstr};")
                else:
                    # the original exception
                    # raise ToVHDLError(_error.UndrivenSignal, s._name)
                    # changed to a warning and a continuous assignment to a wire
                    warnings.warn(f"{_error.UndrivenSignal}: {s._name}", category=ToVHDLWarning)
                    self.constwires.append(s)
                    sigs.append(f"signal {s._name}: {p}{r};")

        for m in memlist:
            if not m._used:
                continue
            # infer attributes for the case of named signals in a list
            for __, s in enumerate(m.mem):
                if not m._driven and s._driven:
                    m._driven = s._driven
                if not m._read and s._read:
                    m._read = s._read
            if not m._driven and not m._read:
                continue
            # Check if VHDL keyword or reused name
            _nameValid(m.name)
            r = _getRangeString(m.elObj)
            p = _getTypeString(m.elObj)
            t = f"(0 to {m.depth} - 1)"  # perhaps t = f"(0 to {m.depth - 1}" is preferable?
            size = len(m.elObj)

            if self.initial_values or isinstance(m.mem[0], Constant):
                if all([each._init == m.mem[0]._init for each in m.mem]):
                    if isinstance(m.mem[0]._init, bool):
                        val_str = f' := (others => \'{int(m.mem[0]._init)}\')'
                    else:
                        val_str = f' := (others => {size}X"{m.mem[0]._init}")'
                else:
                    # group by 8 on a line
                    idx = 0
                    subs = []
                    for __ in range(m.depth // 8):
                        subs.append('\n        ')
                        for __ in range(8):
                            subs.append(f'{size}X"{m.mem[idx]._init:x}", ')
                            idx += 1
                    subs.append('\n        ')

                    # add a possible incomplete line
                    rest = m.depth - idx
                    if rest:
                        for __ in range(rest):
                            subs.append(f'sizeX"{m.mem[idx]._init:x}", ')
                            idx += 1
                        subs.append(['\n'])
                    else:
                        # remove last ', '
                        subs.pop()
                        subs[-1] = subs[-1][:-2]

                    val_str = ' := (' + ''.join(subs) + '\n        )'
            else:
                val_str = ''

            if isinstance(m.mem[0], Constant):
                sigs.append(f"constant {m.name}: array_of_unsigned{t}{r}{val_str};")
            else:
                if not m._driven:
                    warnings.warn(f"{_error.UndrivenSignal}: {m.name}", category=ToVHDLWarning)

                sigs.append(f"signal {m.name,}: array_of_unsigned{t}{r}{val_str};")

        # sort the sigs
        # before adding them to the output file
        self.file.write('    ' + '\n    '.join(sortalign(sigs, sort=True)))
        # self.file.write('    ' + '\n    '.join(sigs))

    def writePortConversions(self):
        pass

    def writeConstantWires(self):
        for s in self.constwires:
            if s._type is bool:
                c = int(s._val)
                pre, suf = "'", "'"
            elif s._type is intbv:
                c = int(s._val)
                w = len(s)
                assert w != 0
                if s._min < 0:
                    if w <= 31:
                        pre, suf = "to_signed(", f", {w})"
                    else:
                        pre, suf = "signed'(", ")"
                        c = f'"{tobin(c, w)}"'
                else:
                    if w <= 31:
                        pre, suf = "to_unsigned(", f", {w})"
                    else:
                        pre, suf = "unsigned'(", ")"
                        c = f'"{tobin(c, w)}"'
            else:
                raise ToVHDLError("Unexpected type for constant signal", s._name)

            self.file.write(f'    {s._name} <= {pre}{c}{suf};\n')

    def writeConcatSignals(self, siglist, memlist):
        # shadow signal assignments
        for s in siglist:
            if hasattr(s, 'toVHDL') and s._read:
                self.file.write(sortalign(s.toVHDL(), sep='<='))
        # hack for slice signals in a list
        for m in memlist:
            if m._read:
                for s in m.mem:
                    if hasattr(s, 'toVHDL'):
                        self.file.write(sortalign(s.toVHDL(), sep='<='))

    def writeModuleFooter(self):
        self.dedent()
        self.file.write(f"\nend architecture {self.architecture};\n")

    def writeTestBench(self, intf):
        pass

    def writeDoc(self, node):
        assert hasattr(node, 'doc')
        self.file.write(_makeDoc(node.doc, '-- ', self.ind))

    def indent(self):
        self.ind += ' ' * 4

    def dedent(self):
        self.ind = self.ind[:-4]

    def emitline(self):
        ''' process the current self.ir list '''
        # print('-- {}'.format(self.ir), file=self.file)
        # del self.ir[:]
        pass

    def close(self):
        self.file.close()

    def _cleanup(self):
        # clean up attributes
        # self.name = None
        self.standard = '2008'
        self.radix = ''
        self.header = ""
        self.no_myhdl_header = False
        self.no_testbench = False
        self.trace = False
        del _usedNames[:]
        self.dunder = 0


def _getRangeString(s):
    if isinstance(s._val, EnumItemType):
        return ''
    elif s._type is bool:
        return ''
    elif s._nrbits is not None:
        msb = s._nrbits - 1
        return f"({msb} downto 0)"
    else:
        raise AssertionError


def _getTypeString(s):
    if isinstance(s._val, EnumItemType):
        return s._val._type._name
    elif s._type is bool:
        return "std_logic"
    if s._min is not None and s._min < 0:
        return "signed"
    else:
        return 'unsigned'


opmap = {
    ast.Add: '+',
    ast.Sub: '-',
    ast.Mult: '*',
    ast.Div: '/',
    ast.Mod: 'mod',
    ast.Pow: '**',
    ast.LShift: 'shift_left',
    ast.RShift: 'shift_right',
    ast.BitOr: 'or',
    ast.BitAnd: 'and',
    ast.BitXor: 'xor',
    ast.FloorDiv: '/',
    ast.Invert: 'not ',
    ast.Not: 'not ',
    ast.UAdd: '+',
    ast.USub: '-',
    ast.Eq: '=',
    ast.Gt: '>',
    ast.GtE: '>=',
    ast.Lt: '<',
    ast.LtE: '<=',
    ast.NotEq: '/=',
    ast.And: 'and',
    ast.Or: 'or',
    }

nameconstant_map = {
    True: "'1'",
    False: "'0'",
    None: "'Z'"
    }


class _ConvertVisitor(ast.NodeVisitor, _ConversionMixin):

    def __init__(self, tree, buf, writer):
        self.tree = tree
        self.buf = buf
        self.returnLabel = tree.name
        self.ind = '    '  # start of indented
        self.isSigAss = False
        self.okSigAss = True
        self.sizeass = None
        self.labelStack = []
        self.context = _context.UNKNOWN
        self.writer = writer

    def raiseError(self, node, kind, msg=""):
        lineno = self.getLineNo(node)
        info = f"in file {self.tree.sourcefile}, line {self.tree.lineoffset + lineno}:\n    "
        raise ConversionError(kind, msg, info)

    def write(self, arg):
        self.buf.write(f"{arg}")

    def writeline(self, nr=1):
        for __ in range(nr):
            self.buf.write("\n")
        self.buf.write(f'{self.ind}')

    def writeDoc(self, node):
        assert hasattr(node, 'doc')
        doc = _makeDoc(node.doc, '-- ', self.ind)
        self.write(doc)
        self.writeline()

    def indent(self):
        self.ind += ' ' * 4

    def dedent(self):
        self.ind = self.ind[:-4]

    def IntRepr(self, obj):
        if obj >= 0:
            s = f"{int(obj)}"
        else:
            s = f"(- {abs(int(obj))})"
        return s

    def BitRepr(self, item, var):
        if isinstance(var._val, bool):
            return f'"{tobin(item, len(var))}"'
        else:
            return f'"{tobin(item, len(var))}"'

    def writeDeclaration(self, obj, name, kind="", direction="", endchar=";", constr=True):
        hdltype = ''
        if isinstance(obj, EnumItemType):
            hdltype = obj._type._name
        elif isinstance(obj, intbv):
            hdltype = f'unsigned({obj._nrbits} - 1 downto 0)'
        elif isinstance(obj, bool):
            hdltype = 'std_logic';

        if kind:
            kind += " "

        if direction:
            direction += " "

        self.write(f"{self.ind}{kind}{name} : {direction}{hdltype}{endchar}")

    def writeDeclarations(self):
        if self.tree.hasPrint:
            self.writeline()
            self.write("variable L: line;")
        for name, obj in self.tree.vardict.items():
            if isinstance(obj, _loopInt):
                continue  # hack for loop vars
            self.writeline()
            self.writeDeclaration(obj, name, kind="variable")

    # def writeAlwaysHeader(self):
    #     self.write(f'{self.tree.name} : process( all )')

    def writeAlwaysBody(self):
        self.write(f'\n{self.ind}begin')
        self.indent()

    def visit_BinOp(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        if isinstance(node.op, ast.Mod) and self.context == _context.PRINT:
            self.visit(node.left)
            self.write(", ")
            self.visit(node.right)
        else:
            if isinstance(node.op, ast.RShift):
                # Additional cast to signed of the full expression
                # this is apparently required by cver - not sure if it
                # is actually required by standard Verilog.
                # It shouldn't hurt however.
                if node.signed:
                    self.write("$signed")

            if hasattr(node, 'toint'):
                node.left.toint = node.toint
                node.right.toint = node.toint

            self.context = None
            if node.signed:
                self.context = _context.SIGNED
            self.write("(")
            self.visit(node.left)
            self.write(" {} ".format(opmap[type(node.op)]))
            self.visit(node.right)
            self.write(")")
            self.context = None
        ic.dedent()

    def checkOpWithNegIntbv(self, node, op):
        if op in ("+", "-", "*", "~", "&&", "||", "!"):
            return
        if isinstance(node, ast.Name):
            o = node.obj
            if isinstance(o, (_Signal, intbv)) and o.min is not None and o.min < 0:
                self.raiseError(node, _error.NotSupported, f"negative intbv with operator {op}")

    def visit_BoolOp(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write("(")
        self.visit(node.values[0])
        for n in node.values[1:]:
            self.write(f" {opmap[type(node.op)]} ")
            self.visit(n)
        self.write(")")
        ic.dedent()

    def visit_UnaryOp(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write(f" ({opmap[type(node.op)]} ")
        self.visit(node.operand)
        self.write(")")
        ic.dedent()

    def visit_Attribute(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        if isinstance(node.ctx, ast.Store):
            self.setAttr(node)
        else:
            self.getAttr(node)
        ic.dedent()

    def setAttr(self, node):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        # any assignment ends up here
        assert node.attr == 'next'
        self.isSigAss = True
        if isinstance(node.value, ast.Name):
            sig = self.tree.symdict[node.value.id]
            self.isSigAss = sig._name
            self.sizeass = sig._nrbits

        self.visit(node.value)
        node.obj = self.getObj(node.value)

    def getAttr(self, node):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        if isinstance(node.value, ast.Subscript):
            self.setAttr(node)
            return

        assert isinstance(node.value, ast.Name), node.value
        n = node.value.id
        if n in self.tree.symdict:
            obj = self.tree.symdict[n]
        elif n in self.tree.vardict:
            obj = self.tree.vardict[n]
        else:
            raise AssertionError("object not found")
        if isinstance(obj, _Signal):
            if node.attr == 'next':
                # sig = self.tree.symdict[node.value.id]
                self.isSigAss = obj._name
                self.sizeass = obj._nrbits
                self.visit(node.value)
            elif node.attr == 'posedge':
                self.write("rising_edge(")
                self.visit(node.value)
                self.write(")")
            elif node.attr == 'negedge':
                self.write("falling_edge(")
                self.visit(node.value)
                self.write(")")
            elif node.attr == 'val':
                pre, suf = self.inferCast(node.vhd, node.vhdOri)
                self.write(pre)
                self.visit(node.value)
                self.write(suf)
        if isinstance(obj, (_Signal, intbv)):
            if node.attr in ('min', 'max'):
                pre, suf = self.inferCast(node.vhd, node.vhdOri)
                self.write(pre)
                self.write(f"{node.obj}")
                self.write(suf)
        if isinstance(obj, EnumType):
            assert hasattr(obj, node.attr)
            e = getattr(obj, node.attr)
            self.write(e._toVHDL())

    def visit_Assert(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        # XXX
        self.write("assert ")
        self.visit(node.test)
        self.indent()
        self.writeline()
        self.write('report "*** AssertionError ***"')
        self.writeline()
        self.write("severity error;")
        self.dedent()
        ic.dedent()

    def visit_Assign(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        lhs = node.targets[0]
        rhs = node.value
        ic (lhs, rhs)
        # shortcut for expansion of ROM in case statement
        if isinstance(rhs, ast.Subscript) and \
                      not isinstance(rhs.slice, ast.Slice) and \
                      isinstance(rhs.value.obj, _Rom):
            rom = rhs.value.obj.rom
            self.write("case ")
            self.visit(rhs.slice)
            self.write(" is")
            self.indent()
            size = len(lhs.obj)
            for i, n in enumerate(rom):
                self.writeline()
                if i == len(rom) - 1:
                    self.write("when others => ")
                else:
                    self.write(f"when {i} => ")
                self.visit(lhs)
                if self.isSigAss:
                    self.write(' <= ')
                    self.isSigAss = False
                else:
                    self.write(' := ')
                if isinstance(lhs.obj._val, bool):
                    self.write(f"'{n}';")
                elif isinstance(lhs.obj._val, intbv):
                    self.write(f'{size}X"{hex(n)[2:]}";')
                else:
                    self.write(f'"{tobin(n, size)}";')
            self.dedent()
            self.writeline()
            self.write("end case;")

        elif isinstance(rhs, ast.ListComp):
            # skip list comprehension assigns for now
            pass

        else:
            # default behavior
            # there should only be a single target
            self.visit(node.targets[0])
            if isinstance(node.targets[0], ast.Attribute) and isinstance(rhs, ast.Constant):
                rhs.dst = node.targets[0].obj

            ic(self.__class__.__name__, pp.pformat(vars(node)))
            if self.isSigAss:
                self.write(' <= ')
                self.isSigAss = False
            else:
                self.write(' := ')
            pre, suf = '', ''

            # ic(repr(lhs.obj), pp.pformat(vars(rhs)))
            # if isinstance(rhs, ast.Compare):
            #     if isinstance(lhs.obj, _Signal):
            #         if isinstance(lhs.obj._val, bool):
            #             pre, suf = 'stdl(', ')'
            #         else:
            #             # intbv? ???
            #             pass
            #     elif isinstance(lhs.obj, bool):
            #         # fine
            #         pass
            #     elif isinstance(lhs.obj, intbv):
            #         # ???
            #         pass
            #
            # elif isinstance(rhs, ast.Name):
            #     pass
            #
            # elif isinstance(rhs, ast.Subscript):
            #     pass

            ic(repr(lhs.obj), pp.pformat(vars(lhs)))
            ic(pp.pformat(vars(rhs)))
            match type(rhs):
                case ast.Compare:
                    if isinstance(lhs.obj, _Signal):
                        if isinstance(lhs.obj._val, bool):
                            pre, suf = 'stdl(', ')'
                        else:
                            # intbv? ???
                            pass
                    else:
                        # must be a variable?
                        pass

                case ast.Name:
                    if isinstance(lhs.obj, _Signal):
                        if isinstance(lhs.obj._val, bool):
                            # pre, suf = 'stdl(', ')'
                            pass
                        else:
                            # intbv? ???
                            pass
                    else:
                        # must be a variable?
                        if isinstance(lhs.obj, intbv):
                            if len(lhs.obj) != len(rhs.obj):
                                pre = 'resize('
                                suf = f', {len(lhs.obj)})'
                        else:
                            # bool?
                            pass

                case ast.Subscript:
                    pass

            self.write(pre)
            self.visit(rhs)
            self.write(suf)
            self.write(';')
            self.writer.emitline()
        ic.dedent()

    def visit_AugAssign(self, node, *args):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        # XXX apparently no signed context required for augmented assigns
        self.visit(node.target)
        self.write(" = ")
        self.visit(node.target)
        self.write(f" {opmap[type(node.op)]} ")
        self.visit(node.value)
        self.write(";")
        self.writer.emitline()
        ic.dedent()

    def visit_Break(self, node,):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write("exit;")
        self.writer.emitline()
        ic.dedent()

    def visit_Call(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.context = None
        fn = node.func
        # assert isinstance(fn, astNode.Name)
        f = self.getObj(fn)

        if f is print:
            self.visit_Print(node)
            ic.dedent()
            return

        fname = ''
        pre, suf = '', ''
        opening, closing = '(', ')'
        if f is bool:
            self.write("(")
            self.visit(node.args[0])
            self.write(" != 0)")
            # self.write(" ? 1'b1 : 1'b0)")
            ic.dedent()
            return
        elif f is len:
            val = self.getVal(node)
            self.require(node, val is not None, "cannot calculate len")
            self.write(repr(val))
            ic.dedent()
            return
        elif f is now:
            self.write(pre)
            self.write(f"(now / 1 {self.writer.timescale})")
            self.write(suf)
            ic.dedent()
            return
        elif f is ord:
            opening, closing = '', ''
            node.args[0].s = str(ord(node.args[0].s))
        elif f is int:
            opening, closing = '', ''
            # convert number argument to integer
            if sys.version_info >= (3, 8, 0):
                if isinstance(node.args[0], ast.Constant):
                    node.args[0].n = int(node.args[0].n)
            else:
                if isinstance(node.args[0], ast.Num):
                    node.args[0].n = int(node.args[0].n)
        elif f in (intbv, modbv):
            self.visit(node.args[0])
            ic.dedent()
            return
        elif f == intbv.signed:  # note equality comparison
            # comes from a getattr
            opening, closing = '', ''
            if not fn.value.signed:
                opening, closing = "signed(", ")"
            self.write(opening)
            self.visit(fn.value)
            self.write(closing)
            ic.dedent()
            return
        elif (type(f) in (type,)) and issubclass(f, Exception):
            self.write(f.__name__)
        elif f in (posedge, negedge):
            opening, closing = ' ', ''
            self.write(f.__name__)
        elif f is concat:
            # pre, suf = self.inferCast(node.vhd, node.vhdOri)
            opening, closing = "unsigned'(", ")"
            sep = " & "
        elif f is delay:
            self.visit(node.args[0])
            ic.dedent()
            return
        elif hasattr(node, 'tree'):
            fname = node.tree.name
        else:
            self.write(f.__name__)

        if node.args:
            self.write(pre)
            # TODO rewrite making use of fname variable
            self.write(fname)
            self.write(opening)
            self.visit(node.args[0])
            for arg in node.args[1:]:
                self.write(sep)
                self.visit(arg)
            self.write(closing)
            self.write(suf)

        if hasattr(node, 'tree'):
            if node.tree.kind == _kind.TASK:
                Visitor = _ConvertTaskVisitor
            else:
                Visitor = _ConvertFunctionVisitor
            v = Visitor(node.tree, self.funcBuf)
            v.visit(node.tree)
        ic.dedent()

    def visit_Compare(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        # self.context = None
        # if node.signed:
        #     self.context = _context.SIGNED
        # self.write("(")
        # self.visit(node.left)
        # self.write(" {} ".format(opmap[type(node.ops[0])]))
        # self.visit(node.comparators[0])
        # self.write(")")
        # self.context = None
        left, op, right = node.left, node.ops[0], node.comparators[0]
        ic(pp.pformat(vars(left)), pp.pformat(vars(right)))
        pre, suf = '', ''
        if isinstance(left, ast.Constant) and isinstance(right.obj, _Signal) and isinstance(right.obj._val, bool):
            pre, suf = 'stdl(', ')'
        self.write(pre)
        self.visit(left)
        self.write(suf)

        self.write(f" {opmap[type(op)]} ")

        pre, suf = '', ''
        if isinstance(right, ast.Constant) and isinstance(left.obj, _Signal) and isinstance(left.obj._val, bool):
            pre, suf = 'stdl(', ')'
        self.write(pre)
        self.visit(right)
        self.write(suf)
        ic.dedent()

    def visit_Constant(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        if node.value is None:
            # NameConstant
            self.write(nameconstant_map[node.obj])

        elif isinstance(node.value, bool):
            if self.context == _context.BOOLEAN:
                self.write(str(node.value))
            else:
                self.write(nameconstant_map[node.obj])

        elif isinstance(node.value, int):
            # Num
            if self.context == _context.PRINT:
                self.write(f'"{node.value}"')
            elif self.context == _context.BOOLEAN:
                self.write(str(bool(node.value)))
            else:
                if hasattr(node, 'dst') and isinstance(node.dst._val, bool):
                    self.write(nameconstant_map[bool(node.obj)])
                elif hasattr(node, 'dst') and isinstance(node.dst._val, intbv):
                    self.write(f'{len(node.dst)}X"{hex(node.value)[2:]}"')
                else:
                    self.write(self.IntRepr(node.value))

        elif isinstance(node.value, str):
            # Str
            s = node.value
            if self.context == _context.PRINT:
                self.write(f'"{s}"')
            elif len(s) == s.count('0') + s.count('1'):
                self.write(f"{len(s)}'b{s}")
            else:
                self.write(s)
        ic.dedent()

    def visit_Continue(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write("next;")
        ic.dedent()

    def visit_Expr(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        expr = node.value
        # docstrings on unofficial places
        if isinstance(expr, ast.Str):
            doc = _makeDoc(expr.s, '-- ')
            self.write(doc)
            ic.dedent()
            return
        # skip extra semicolons
        if isinstance(expr, ast.Constant):
            ic.dedent()
            return
        self.visit(expr)
        # ugly hack to detect an orphan "task" call
        if isinstance(expr, ast.Call) and hasattr(expr, 'tree'):
            self.write(';')
        ic.dedent()

    def visit_IfExp(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        # # propagate the node's sig attribute
        # node.body.sig = node.orelse.sig = node.sig
        # self.write('tern_op(')
        # self.write('cond => ')
        # self.visit(node.test)
        # self.write(', if_true => ')
        # self.visit(node.body)
        # self.write(', if_false => ')
        # self.visit(node.orelse)
        # self.write(')')
        # q <= '0' when reset else d;
        self.visit(node.body)
        self.write(' when ')
        self.visit(node.test)
        self.write(' else ')
        self.visit(node.orelse)
        ic.dedent()

    def visit_For(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.labelStack.append(node.breakLabel)
        self.labelStack.append(node.loopLabel)
        var = node.target.id
        cf = node.iter
        f = self.getObj(cf.func)
        args = cf.args
        assert len(args) <= 3
        self.require(node, len(args) < 3, "explicit step not supported")
        self.require(node, len(args) > 0, "at least one argument requested")
        if f is range:
            op = 'to'
            if len(args) == 1:
                start, stop, step = None, args[0], None
            elif len(args) == 2:
                start, stop, step = args[0], args[1], None
            else:
                start, stop, step = args
        else:  # downrange
            op = 'downto'
            if len(args) == 1:
                start, stop, step = args[0], None, None
            elif len(args) == 2:
                start, stop, step = args[0], args[1], None
            else:
                start, stop, step = args
        assert step is None
        # if node.breakLabel.isActive:
        # #             self.write("begin: %s" % node.breakLabel)
        # self.writeline()
        # if node.loopLabel.isActive:
        # #             self.write("%s: " % node.loopLabel)
        if var == '__':
            var = f'i{self.writer.dunder}'
            self.writer.dunder += 1

        self.write(f"for {var} in ")
        if start is None:
            self.write("0")
        else:
            self.visit(start)
            if f is downrange:
                self.write("-1")
        self.write(f" {op} ")
        if stop is None:
            self.write("0")
        else:
            self.visit(stop)
            if f is range:
                self.write("-1")
        self.write(" loop")
        self.indent()
        self.visit_stmt(node.body)
        self.dedent()
        self.writeline()
        self.write("end loop;")
# if node.breakLabel.isActive:
# self.writeline()
# self.write("end")
        self.labelStack.pop()
        self.labelStack.pop()
        ic.dedent()

    def visit_FunctionDef(self, node):
        raise AssertionError("To be implemented in subclass")

    def visit_If(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        if node.ignore:
            ic.dedent()
            return
        # only map to VHDL case if it's a full case
        if node.isFullCase:
            self.mapToCase(node)
        else:
            self.mapToIf(node)
        ic.dedent()

    def visit_Match(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write("case (")
        self.visit(node.subject)
        self.write(")")
        self.indent()
        for case in node.cases:
            self.visit(case)
            self.writeline()

        self.dedent()
        self.writeline()
        self.write("endcase")
        ic.dedent()

    def visit_match_case(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        pattern = node.pattern
        self.visit(pattern)

        self.write(": begin ")
        self.indent()
        # Write all the multiple assignment per case
        for stmt in node.body:
            self.writeline()
            self.visit(stmt)
        self.dedent()
        self.writeline()
        self.write("end")
        ic.dedent()

    def visit_MatchValue(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        item = node.value
        obj = self.getObj(item)

        if isinstance(obj, EnumItemType):
            itemRepr = obj._toVerilog()
        else:
            itemRepr = self.IntRepr(item.value, radix='hex')

        self.write(itemRepr)
        ic.dedent()

    def visit_MatchSingleton(self, node):
        raise AssertionError(f"Unsupported Match type {type(node)} ")

    def visit_MatchSequence(self, node):
        raise AssertionError(f"Unsupported Match type {type(node)} ")

    def visit_MatchStar(self, node):
        raise AssertionError(f"Unsupported Match type {type(node)} ")

    def visit_MatchMapping(self, node):
        raise AssertionError(f"Unsupported Match type {type(node)} ")

    def visit_MatchClass(self, node):
        ic.indent()
        for pattern in node.patterns:
            self.visit(pattern)
        ic.dedent()

    def visit_MatchAs(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        if node.name is None and  node.pattern is None:
            self.write("default")
        else:
            raise AssertionError(f"Unknown name {node.name} or pattern {node.pattern}")
        ic.dedent()

    def visit_MatchOr(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        for i, pattern in enumerate(node.patterns):
            self.visit(pattern)
            if not i == len(node.patterns) - 1:
                self.write(" | ")
        ic.dedent()

    def mapToCase(self, node, *args):
        var = node.caseVar
        obj = self.getObj(var)
        self.write("case ")
        self.visit(var)
        self.write(" is")
        self.indent()
        for i, (test, suite) in enumerate(node.tests):
            self.writeline()
            item = test.case[1]
            if isinstance(item, EnumItemType):
                itemRepr = item._toVHDL()
            elif hasattr(obj, '_nrbits'):
                itemRepr = self.BitRepr(item, obj)
            else:
                itemRepr = i
            comment = ""
            # potentially use default clause for last test
            if (i == len(node.tests) - 1) and not node.else_:
                self.write("when others")
                comment = " -- {}".format(itemRepr)
            else:
                self.write("when ")
                self.write(itemRepr)
            self.write(f" => {comment}")
            self.indent()
            self.visit_stmt(suite)
            self.dedent()
        if node.else_:
            self.writeline()
            self.write("when others =>")
            self.indent()
            self.visit_stmt(node.else_)
            self.dedent()
        self.dedent()
        self.writeline()
        self.write("end case;")

    def mapToIf(self, node, *args):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        first = True
        for test, suite in node.tests:
            if first:
                ifstring = "if "
                first = False
            else:
                ifstring = "elsif "
                self.writeline()
            self.write(ifstring)
            self.visit(test)
            self.write(" then")
            self.indent()
            self.visit_stmt(suite)
            self.dedent()
        if node.else_:
            self.writeline()
            edges = self.getEdge(node)
            if edges is not None:
                edgeTests = [e._toVHDL() for e in edges]
                self.write("elsif ")
                self.write(" or ".join(edgeTests))
                self.write(" then")
            else:
                self.write("else")
            self.indent()
            self.visit_stmt(node.else_)
            self.dedent()
        self.writeline()
        self.write("end if;")

    def visitKeyword(self, node, *args):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.visit(node.expr)

    def visit_Module(self, node, *args):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        for stmt in node.body:
            self.visit(stmt)
        ic.dedent()

    def visit_ListComp(self, node):
        # do nothing
        pass

    def visit_Name(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        if isinstance(node.ctx, ast.Store):
            self.setName(node)
        else:
            self.getName(node)
        ic.dedent()

    def setName(self, node):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write(node.id)

    def getName(self, node):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        n = node.id
        pre, suf = '', ''
        if n == 'False':
            if isinstance(node.obj._val, bool):
                s = "'0'"
            else:
                s = "False"
        elif n == 'True':
            if isinstance(node.obj._val, bool):
                s = "'1'"
            else:
                s = "True"
        elif n == 'None':
            if isinstance(node.obj._val, bool):
                s = "'Z'"
            else:
                assert hasattr(node.vhd, 'size')
                s = '"{}"'.format('Z' * node.vhd.size)
        elif n in self.tree.vardict:
            s = n
            # obj = self.tree.vardict[n]
            # ori = inferVhdlObj(obj)
            # pre, suf = self.inferCast(node.vhd, ori)
            # s = "%s%s%s" % (pre, s, suf)

        elif n in self.tree.argnames:
            assert n in self.tree.symdict
            # obj = self.tree.symdict[n]
            # vhd = inferVhdlObj(obj)
            # if isinstance(vhd, vhd_std_logic) and isinstance(node.vhd, vhd_boolean):
            #     s = "({} = '1')".format(n)
            # else:
            #     s = n
            s = n
        elif n in self.tree.symdict:
            obj = self.tree.symdict[n]
            s = n
            ic(repr(n), repr(obj))
            # if isinstance(obj, bool):
            #     if isinstance(node.vhd, vhd_std_logic):
            #         s = "'%s'" % int(obj)
            #     else:
            #         s = "%s" % obj
            # elif isinstance(obj, int):
            #     if isinstance(node.vhd, vhd_int):
            #         s = self.IntRepr(obj)
            #     elif isinstance(node.vhd, vhd_boolean):
            #         s = "%s" % bool(obj)
            #     elif isinstance(node.vhd, vhd_std_logic):
            #         s = "'%s'" % int(obj)
            #     elif isinstance(node.vhd, vhd_unsigned):
            #         if abs(obj) < 2 ** 31:
            #             s = "to_unsigned(%s, %s)" % (obj, node.vhd.size)
            #         else:
            #             s = 'unsigned\'("%s")' % tobin(obj, node.vhd.size)
            #     elif isinstance(node.vhd, vhd_signed):
            #         if abs(obj) < 2 ** 31:
            #             s = "to_signed(%s, %s)" % (obj, node.vhd.size)
            #         else:
            #             s = 'signed\'("%s")' % tobin(obj, node.vhd.size)
            # elif isinstance(obj, tuple):  # Python3.9+ ast.Index replacement serves a tuple
            #     s = n
            # elif isinstance(obj, _Signal):
            if isinstance(obj, bool):
                pass
            #     if isinstance(node.vhd, vhd_std_logic):
            #         s = "'%s'" % int(obj)
            #     else:
            #         s = "%s" % obj

            elif isinstance(obj, int):
                s = self.IntRepr(obj)

            elif isinstance(obj, str):
                s = f'"{obj}"'

            elif isinstance(obj, _Signal):
                s = str(obj)
                if hasattr(node, 'toint') and node.toint:
                    pre, suf = 'to_integer(', ')'

            elif _isMem(obj):
                m = _getMemInfo(obj)
                assert m.name
                s = m.name

            elif isinstance(obj, EnumItemType):
                s = obj._toVHDL()

            elif (type(obj) in (type,)) and issubclass(obj, Exception):
                s = n

            else:
                self.raiseError(node, _error.UnsupportedType, f"{n}, {type(obj)}")

        else:
            raise AssertionError(f"name ref: {n}")

        self.write(pre)
        self.write(s)
        self.write(suf)
        if hasattr(node, 'toint'):
            node.toint = False

    def visit_Pass(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write("null;")
        ic.dedent()

    def visit_Print(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        argnr = 0
        for s in node.format:
            if isinstance(s, str):
                self.write(f'write(L, string\'("{s}"));')
            else:
                ic(repr(s), repr(s.conv))
                a = node.args[argnr]
                argnr += 1
                pre, suf = '', ''
                if s.conv is int:
                    pre = 'to_string(', ')'
                    # a.vhd = vhd_int()
                elif s.conv is str:
                    pre = 'string\'('
                    suf = ')'
                # else:
                #     if isinstance(a.vhdOri, vhd_vector):
                #         to_string = "to_hstring"
                #         # to_hstring correctly does sign extension
                #         # however, Verilog doesn not: therefore, interprete
                #         # print values as unsigned...
                #         a.vhd = vhd_unsigned(a.vhd.size)
                #     elif isinstance(a.vhdOri, vhd_std_logic):
                #         a.vhd = vhd_boolean()
                self.write(f"write(L,")
                self.write(pre)
                self.visit(a)
                self.write(suf)
                self.write(")")
                self.write(';')
            self.writeline()
        self.write("writeline(output, L);")
        ic.dedent()

    def visit_Raise(self, node):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        self.write('assert False report "End of Simulation" severity Failure;')

    def visit_Return(self, node):
        pass

    def visit_Subscript(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        if isinstance(node.slice, ast.Slice):
            self.accessSlice(node)
        else:
            self.accessIndex(node)
        ic.dedent()

    def accessSlice(self, node):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))

        if isinstance(node.value, ast.Call) and \
           node.value.func.obj in (intbv, modbv) and \
           _isConstant(node.value.args[0], self.tree.symdict):
            # c = self.getVal(node)._val
            # pre, post = "", ""
            # if node.vhd.size <= 30:
            #     if isinstance(node.vhd, vhd_unsigned):
            #         pre, post = "to_unsigned(", ", %s)" % node.vhd.size
            #     elif isinstance(node.vhd, vhd_signed):
            #         pre, post = "to_signed(", ", %s)" % node.vhd.size
            # else:
            #     if isinstance(node.vhd, vhd_unsigned):
            #         pre, post = "unsigned'(", ")"
            #         c = '"%s"' % tobin(c, node.vhd.size)
            #     elif isinstance(node.vhd, vhd_signed):
            #         pre, post = "signed'(", ")"
            #         c = '"%s"' % tobin(c, node.vhd.size)
            # self.write(pre)
            # self.write("%s" % c)
            # self.write(post)
            raise NotImplementedError('accessSlice')
            return

        # pre, suf = self.inferCast(node.vhd, node.vhdOri)
        # if isinstance(node.value.vhd, vhd_signed) and isinstance(node.ctx, ast.Load):
        #     pre = pre + "unsigned("
        #     suf = ")" + suf

        self.context = None
        self.visit(node.value)
        lower, upper = node.slice.lower, node.slice.upper
        # special shortcut case for [:] slice
        if lower is None and upper is None:
            pass
        else:
            self.write("(")
            if lower is None:
                self.write(f"{node.obj._nrbits}")
            else:
                lower.toint = True
                self.visit(lower)
            self.write(" - 1 downto ")
            if upper is None:
                self.write("0")
            else:
                upper.toint = True
                self.visit(upper)
            self.write(")")

    def accessIndex(self, node):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))

        self.visit(node.value)
        self.write("(")
        self.visit(node.slice)
        self.write(")")
        ic.dedent()

    def visit_stmt(self, body):
        # 'body' is a list of statements
        ic.indent()
        ic(self.__class__.__name__, body, pp.pformat(vars(self)))
        for stmt in body:
            # ic(self.__class__.__name__, astdump(stmt, show_offsets=False), pp.pformat(vars(stmt)))
            self.writeline()
            self.visit(stmt)
            # ugly hack to detect an orphan "task" call
            if isinstance(stmt, ast.Call) and hasattr(stmt, 'tree'):
                self.write(';')
        ic.dedent()

    def visit_Tuple(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        assert self.context != None
        sep = ", "
        tpl = node.elts
        self.visit(tpl[0])
        for elt in tpl[1:]:
            self.write(sep)
            self.visit(elt)
        ic.dedent()

    def visit_While(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        self.labelStack.append(node.breakLabel)
        self.labelStack.append(node.loopLabel)
        self.write("while ")
        self.context = _context.BOOLEAN
        self.visit(node.test)
        self.context = _context.UNKNOWN
        self.write(" loop")
        self.indent()
        self.visit_stmt(node.body)
        self.dedent()
        self.writeline()
        self.write("end loop")
        self.write(";")
        self.labelStack.pop()
        self.labelStack.pop()
        ic.dedent()

    def visit_Yield(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        self.write("wait ")
        yieldObj = self.getObj(node.value)
        suf = ''
        if isinstance(yieldObj, delay):
            self.write("for ")
            suf = f' * 1 {self.writer.timescale}'
        elif isinstance(yieldObj, _WaiterList):
            self.write("until ")
        else:
            self.write("on ")
        self.context = _context.YIELD
        self.visit(node.value)
        self.context = _context.UNKNOWN
        self.write(suf)
        self.write(";")
        ic.dedent()

    def manageEdges(self, ifnode, senslist):
        """ Helper method to convert MyHDL style template into VHDL style"""
        first = senslist[0]
        if isinstance(first, _WaiterList):
            bt = _WaiterList
        elif isinstance(first, _Signal):
            bt = _Signal
        elif isinstance(first, delay):
            bt = delay
        assert bt
        for e in senslist:
            if not isinstance(e, bt):
                self.raiseError(ifnode, "base type error in sensitivity list")
        if len(senslist) >= 2 and bt == _WaiterList:
            # ifnode = node.code.nodes[0]
            # print ifnode
            assert isinstance(ifnode, ast.If)
            asyncEdges = []
            for test, suite in ifnode.tests:
                e = self.getEdge(test)
                if e is None:
                    self.raiseError(ifnode, "No proper edge value test")
                asyncEdges.append(e)
            if not ifnode.else_:
                self.raiseError(ifnode, "No separate else clause found")
            edges = []
            for s in senslist:
                for e in asyncEdges:
                    if s is e:
                        break
                else:
                    edges.append(s)
            ifnode.edge = edges
            senslist = [s.sig for s in senslist]
        return senslist


class _ConvertAlwaysVisitor(_ConvertVisitor):

    def __init__(self, tree, blockBuf, funcBuf, writer):
        _ConvertVisitor.__init__(self, tree, blockBuf, writer)
        self.funcBuf = funcBuf

    def visit_FunctionDef(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.writeDoc(node)
        w = node.body[-1]
        y = w.body[0]
        if isinstance(y, ast.Expr):
            y = y.value
        assert isinstance(y, ast.Yield)
        senslist = y.senslist
        senslist = self.manageEdges(w.body[1], senslist)
        singleEdge = (len(senslist) == 1) and isinstance(senslist[0], _WaiterList)
        self.write("%s: process (" % self.tree.name)
        if singleEdge:
            self.write(senslist[0].sig)
        else:
            for e in senslist[:-1]:
                self.write(e)
                self.write(', ')
            self.write(senslist[-1])
        self.write(") is")
        self.indent()
        self.writeDeclarations()
        self.dedent()
        self.writeline()
        self.write("begin")
        self.indent()
        if singleEdge:
            self.writeline()
            self.write("if %s then" % senslist[0]._toVHDL())
            self.indent()
        # assert isinstance(w.body, ast.stmt)
        for stmt in w.body[1:]:
            self.writeline()
            self.visit(stmt)
        self.dedent()
        if singleEdge:
            self.writeline()
            self.write("end if;")
            self.dedent()
        self.writeline()
        self.write("end process %s;" % self.tree.name)
        self.writeline(2)

        ic.dedent()


class _ConvertInitialVisitor(_ConvertVisitor):

    def __init__(self, tree, blockBuf, funcBuf, writer):
        _ConvertVisitor.__init__(self, tree, blockBuf, writer)
        self.funcBuf = funcBuf

    def visit_FunctionDef(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.writeDoc(node)
        self.write(f"{self.tree.name}: process\n")
        self.writeline()
        self.writeDeclarations()
        self.write("begin")
        self.indent()
        self.visit_stmt(node.body)
        self.dedent()
        self.writeline()
        self.write("end process;")
        self.writeline(2)
        ic.dedent()


class _ConvertAlwaysCombVisitor(_ConvertVisitor):

    def __init__(self, tree, blockBuf, funcBuf, writer):
        _ConvertVisitor.__init__(self, tree, blockBuf, writer)
        # if self.writer.prefer_blocking_assignments:
        #     self.okSigAss = False
        self.funcBuf = funcBuf

    def visit_FunctionDef(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self)))
        self.writeDoc(node)
        self.write(f'{self.tree.name} : process( all )')
        self.writeDeclarations()
        self.writeAlwaysBody()
        self.visit_stmt(node.body)
        self.dedent()
        self.writeline()
        self.write("end process;")
        self.writeline(2)
        ic.dedent()


class _ConvertSimpleAlwaysCombVisitor(_ConvertVisitor):

    def __init__(self, tree, blockBuf, funcBuf, writer):
        _ConvertVisitor.__init__(self, tree, blockBuf, writer)
        self.funcBuf = funcBuf

    # def visit_Attribute(self, node):
    #     ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
    #     if isinstance(node.ctx, ast.Store):
    #         # no need to intercept '-- OpenPort' signals
    #         # # try intercepting '-- OpenPort' signals
    #         # if isinstance(node.value, ast.Name):
    #         #     obj = self.tree.symdict[node.value.id]
    #         #     if obj._name.startswith('-- OpenPort'):
    #         #         self.write('-- ')
    #
    #         # self.visit(node.value)
    #         self.setAttr(node)
    #     else:
    #         self.getAttr(node)

    def visit_FunctionDef(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.writeDoc(node)
        self.visit_stmt(node.body)
        self.writeline(2)
        ic.dedent()


class _ConvertAlwaysDecoVisitor(_ConvertVisitor):

    def __init__(self, tree, blockBuf, funcBuf, writer):
        _ConvertVisitor.__init__(self, tree, blockBuf, writer)
        self.funcBuf = funcBuf

    def visit_FunctionDef(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.writeDoc(node)
        assert self.tree.senslist
        senslist = self.tree.senslist
        senslist = self.manageEdges(node.body[-1], senslist)
        singleEdge = (len(senslist) == 1) and isinstance(senslist[0], _WaiterList)
        self.write("%s: process (" % self.tree.name)
        if singleEdge:
            self.write(senslist[0].sig)
        else:
            for e in senslist[:-1]:
                self.write(e)
                self.write(', ')
            self.write(senslist[-1])
        self.write(") is")
        self.indent()
        self.writeDeclarations()
        self.dedent()
        self.writeline()
        self.write("begin")
        self.indent()
        if singleEdge:
            self.writeline()
            self.write("if %s then" % senslist[0]._toVHDL())
            self.indent()
        self.visit_stmt(node.body)
        self.dedent()
        if singleEdge:
            self.writeline()
            self.write("end if;")
            self.dedent()
        self.writeline()
        self.write("end process %s;" % self.tree.name)
        self.writeline(2)
        ic.dedent()


def _convertInitVal(reg, init):
    pre, suf = '', ''
    if isinstance(reg, _Signal):
        tipe = reg._type
    else:
        assert isinstance(reg, intbv)
        tipe = intbv
    if tipe is bool:
        v = "'1'" if init else "'0'"
    elif tipe is intbv:
        init = int(init)  # int representation
        vhd_tipe = 'unsigned'
        if reg._min is not None and reg._min < 0:
            vhd_tipe = 'signed'
        if abs(init) < 2 ** 31:
            v = f'{pre}to_{vhd_tipe}({init}, {len(reg)}){suf}'
        else:
            v = f'{pre}{vhd_tipe}\'("{tobin(init, len(reg))}"){suf}'
    else:
        assert isinstance(init, EnumItemType)
        v = init._toVHDL()
    return v


class _ConvertAlwaysSeqVisitor(_ConvertVisitor):

    def __init__(self, tree, blockBuf, funcBuf, writer):
        _ConvertVisitor.__init__(self, tree, blockBuf, writer)
        self.funcBuf = funcBuf

    def visit_FunctionDef(self, node):
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)), pp.pformat(vars(self.tree)))
        self.writeDoc(node)
        assert self.tree.senslist
        senslist = self.tree.senslist
        edge = senslist[0]
        reset = self.tree.reset
        isasync = reset is not None and reset.isasync
        sigregs = self.tree.sigregs
        varregs = self.tree.varregs
        self.write("{}: process (".format(self.tree.name))
        self.write(edge.sig)
        if isasync:
            self.write(', ')
            self.write(reset)
        self.write(") is")
        self.indent()
        self.writeDeclarations()
        self.dedent()
        self.writeline()
        self.write("begin")
        self.indent()
        if not isasync:
            self.writeline()
            self.write(f"if {edge._toVHDL()} then")
            self.indent()
        if reset is not None:
            self.writeline()
            self.write(f"if ({reset} = '{int(reset.active)}') then")
            self.indent()
            for s in sigregs:
                self.writeline()
                self.write(f"{s} <= {_convertInitVal(s, s._init)};")
            for v in varregs:
                n, reg, init = v
                self.writeline()
                self.write(f"{n} := {_convertInitVal(reg, init)};")
            self.dedent()
            self.writeline()
            if isasync:
                self.write(f"elsif {edge._toVHDL()} then")
            else:
                self.write("else")
            self.indent()
        self.visit_stmt(node.body)
        self.dedent()
        if reset is not None:
            self.writeline()
            self.write("end if;")
            self.dedent()
        if not isasync:
            self.writeline()
            self.write("end if;")
            self.dedent()
        self.writeline()
        self.write(f"end process {self.tree.name};")
        self.writeline(2)


class _ConvertFunctionVisitor(_ConvertVisitor):

    def __init__(self, tree, funcBuf, writer):
        _ConvertVisitor.__init__(self, tree, funcBuf, writer)
        self.returnObj = tree.returnObj
        self.returnLabel = _Label("RETURN")

    def writeOutputDeclaration(self):
        self.write(self.tree.vhd.toStr(constr=False))

    def writeInputDeclarations(self):
        endchar = ""
        for name in self.tree.argnames:
            self.write(endchar)
            endchar = ";"
            obj = self.tree.symdict[name]
            self.writeline()
            self.writeDeclaration(obj, name, dir="in", constr=False, endchar="")

    def visit_FunctionDef(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write(f"function {self.tree.name}(")
        self.indent()
        self.writeInputDeclarations()
        self.writeline()
        self.write(") return ")
        self.writeOutputDeclaration()
        self.write(" is")
        self.writeDeclarations()
        self.dedent()
        self.writeline()
        self.write("begin")
        self.indent()
        self.visit_stmt(node.body)
        self.dedent()
        self.writeline()
        self.write(f"end function {self.tree.name};")
        self.writeline(2)
        ic.dedent()

    def visit_Return(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write("return ")
        node.value.vhd = self.tree.vhd
        self.visit(node.value)
        self.write(";")
        ic.dedent()


class _ConvertTaskVisitor(_ConvertVisitor):

    def __init__(self, tree, funcBuf, writer):
        _ConvertVisitor.__init__(self, tree, funcBuf, writer)
        self.returnLabel = _Label("RETURN")

    def writeInterfaceDeclarations(self):
        endchar = ""
        for name in self.tree.argnames:
            self.write(endchar)
            endchar = ";"
            obj = self.tree.symdict[name]
            output = name in self.tree.outputs
            input = name in self.tree.inputs
            inout = input and output
            direction = (inout and "inout") or (output and "out") or "in"
            self.writeline()
            if isinstance(obj, _Signal):
                kind = 'signal'
            else:
                kind = ''
            self.writeDeclaration(obj, name, kind=kind, direction=direction,
                                  constr=False, endchar="")

    def visit_FunctionDef(self, node):
        ic.indent()
        ic(self.__class__.__name__, astdump(node, show_offsets=False), pp.pformat(vars(node)))
        self.write(f"procedure {self.tree.name}")
        if self.tree.argnames:
            self.write("(")
            self.indent()
            self.writeInterfaceDeclarations()
            self.write(")")
        self.write(" is")
        self.writeDeclarations()
        self.dedent()
        self.writeline()
        self.write("begin")
        self.indent()
        self.visit_stmt(node.body)
        self.dedent()
        self.writeline()
        self.write(f"end procedure{self.tree.name};")
        self.writeline(2)
        ic.dedent()

# def _writeTestBench(f, intf, trace=False):
#     print("module tb_{};".format(intf.name), file=f)
#     print(file=f)
#     fr = StringIO()
#     to = StringIO()
#     pm = StringIO()
#     for portname in intf.argnames:
#         s = intf.argdict[portname]
#         r = _getRangeString(s)
#         if s._driven:
#             print("wire {}{};".format(r, portname), file=f)
#             print("        {},".format(portname), file=to)
#         else:
#             print("reg {}{};".format(r, portname), file=f)
#             print("        {},".format(portname), file=fr)
#         print("    {},".format(portname), file=pm)
#     print(file=f)
#     print("initial begin", file=f)
#     if trace:
#         print('    $dumpfile("{}.vcd");'.format(intf.name, file=f)
#         print('    $dumpvars(0, dut);', file=f)
#     if fr.getvalue():
#         print("    $from_myhdl(", file=f)
#         print(fr.getvalue()[:-2], file=f)
#         print("    );", file=f)
#     if to.getvalue():
#         print("    $to_myhdl(", file=f)
#         print(to.getvalue()[:-2], file=f)
#         print("    );", file=f)
#     print("end", file=f)
#     print(file=f)
#     print("{} dut(".format(intf.name), file=f)
#     print(pm.getvalue()[:-2], file=f)
#     print(");", file=f)
#     print(file=f)
#     print("endmodule", file=f)

# def _getRangeString(s):
#     if s._type is bool:
#         return ''
#     elif s._nrbits is not None:
#         nrbits = s._nrbits
#         return "[{}:0] ".format(nrbits - 1)
#     else:
#         raise AssertionError


def _getSignString(s):
    if s._min is not None and s._min < 0:
        return "signed "
    else:
        return ''

# def _intRepr(n, radix=''):
#     # write size for large integers (beyond 32 bits signed)
#     # with some safety margin
#     # XXX signed indication 's' ???
#     p = abs(n)
#     size = ''
#     num = str(p).rstrip('L')
#     if radix == "hex" or p >= 2 ** 30:
#         radix = "'h"
#         num = hex(p)[2:].rstrip('L')
#     if p >= 2 ** 30:
#         size = int(math.ceil(math.log(p + 1, 2))) + 1  # sign bit!
# #            if not radix:
# #                radix = "'d"
#     r = f"{size}{radix}{num}"
#     if n < 0:  # add brackets and sign on negative numbers
#         r = f"(-{r})")
#     return r


if __name__ == '__main__':
    pass
